2016-10-29

第三章	指针和函数


要理解函数及其和指针的结合使用，需要理解程序栈，函数调用时会创建函数的栈并将其推到程序栈上。
函数返回时，其栈从程序栈上弹出。

在使用函数时，两种情况指针很有用，首先是将指针传递给函数，这时函数可以修改指针所引用的数据
也可以高效的传输大块信息。另一种情况就是声名函数指针，本质上函数表示法就是指针表示法。函数名字
经过求值会变成函数的地址，然后函数参数会被传递给函数。

局部变量也成为自动变量，它们总是分配在栈上。

程序栈

程序栈是支持函数执行的内存区域，通常和堆共享，也就是说它们共享同一块内存区域。
程序栈存放栈(stack fram),栈有时也成为活跃记录(activation record),或活跃栈(activation fram)

将栈推到程序栈上时，系统可能会耗尽内存，这种情况称为栈溢出，通常会导致程序非正常终止，要牢记每个线程
通常都会有自己的栈，一个或多个线程访问内存中的同一个对象可能会导致冲突。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声名为全局可访问。这意味着只有需要访问这个对象的函数
才有访问权限，而且也不需要复制对象。

传递参数包括指针时，传递的是它们的值，也就是说传递给函数的是参数值的一个副本，当涉及大型数据结构时，传递参数的指针
会更高效。


返回指针

返回指针很容易，只要返回的类型是某种数据类型的指针即可，从函数返回对象时经常用到以下两种技术：

使用malloc在函数内部分配内存并返回地址。调用者负责释放返回的内存。
传递一个对象给函数并让函数修改它。

从函数返回指针时可能存在几个潜在的问题，包括：

返回未初始化的指针
返回指向无效地址的指针
返回局部变量的指针
返回指针但是没有释放内存

传递指针的指针

将指针传递给函数，传递的是值。如果我们想修改原指针而不是指针的副本，就需要传递指针的指针。


void saferFree(void **pp)
{
	if(pp != NULL && *pp != NULL)
	{
		free(*pp);
		*pp = NULL;
	}
}


saferfree函数调用实际释放内存的free函数，前者的参数声名为void指针的指针。使用指针的指针允许我们修改传入的指针，而使用
void类型可以传入所有类型的指针。

定义宏来实现指针类型的强制转换

#define safeFree(p)  saferFree((void**)&(p))



函数指针

函数指针是持有函数地址的指针。

					
声名一个函数指针：void(*foo)()

该函数接受空参数，返回空值，使用函数指针时c不会检查参数传递是否正确

函数指针命名约定建议是用fprt做函数指针的前缀



为函数指针声名一个类型定义：

typedef int (*funcptr)(int);

funcptr fptr2;


















